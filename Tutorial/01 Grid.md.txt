# Grids

This tutorial is going to show you how to use the multi-dimensional aray class from SciEng. It shows you how to create them, access the data in them, modify them and do elementwise maths with them.

C++ doesn't include a native multi-dimensional array. I always found that a bit strange. There is std::vector for 1-d arrays and since C++23 there is now std::mdspan, which allows you to treat a 1-d array as a multi-d array, but sometimes you just really want a multi-d array.

I actually wrote most of the multi-d array code before I knew about std::mdspan. Maybe I wouldn't have done it if I'd known, but my implementation does some things that std::mdspan doesn't, so I don't feel bad. Another potentially good option is Eigen. Check them out. It's more mature than me, but I think it's not as easy to use.

So let's start with a basic minimal example.

    #include<scieng/grid.h>
    
    int main()
    {
        std::array<size_t, 2> shape{ 2,2 }; //We're going to create a 2 x 2 grid
        sci::GridData<double, 2> firstGrid(shape, 1.0); //create the grid and fill it with 1.0s
        
        return 0;
    }

If you run this, it won't do much. But if you run it in an interactive debugger, you'll be able to dive into the firstGrid object and see that it consists of 4 1s.

Let's use the [] operator to access the elements and output some data. Change the code to the followi

    #include<scieng/grid.h>
    #include<iostream>
    
    int main()
    {
        std::array<size_t, 2> shape{ 2,2 }; //We're going to create a 2 x 2 grid
        sci::GridData<double, 2> firstGrid(shape, 1.0); //create the grid and fill it with 1.0s
    
        firstGrid[1][1] = 2.0; //change element [1][1] to be 2.0
    
        std::cout << firstGrid[0][0] << ", " << firstGrid[0][1] << "\n";
        std::cout << firstGrid[1][0] << ", " << firstGrid[1][1] << "\n";

        return 0;
    }

As you can see, we access the elements just the same way as an array of arrays. So you might reasonably ask, why shouldn't we just create a std::vector of std::vectors? This would give us 2 dimensions. We can just increase that nesting to create more dimensions.

Well, here is why

1. Speed. For nested vectors, you must follow a pointer for each dimension. This is slower than calculating the offset from the beginning of the array and going straight there.
2. Shape. Nested vectors can end up not being rectangular. You could accidentally make a row a different size than the rest, causing invalid data access.
3. Size. You must store the length of the row in every row.

It might seem like point 3 is the least important, but it is actually the main reason why I stopped using nested vectors and wrote the GridData class. I had to store a 3-d data set of floats, which should have taken up about 3 GB in memory. However, slightly frustratingly, the last dimension had size 1, so the final set of nested vectors each had only one element. Each of those vectors contained 4 bytes of actual data (the size of a float), plus an 8-byte pointer, pointing to the first element, plus an 8-byte value indicating the length of the vector (which was always 1). This ballooned my data to about 15 GB, which was enough to grind my laptop to a halt at the time.

Let's dissect the code a little bit. `sci::Grid` takes two template parameters. The data type it will contain and the number of dimensions. The data type should be anything that you can put in a `std::vector`. If that doesn't work, please file a bug report. The number of dimensions can be anything you want.

The constructor used here accepts a shape, which is a `std::array<size_t, ndims>` where `ndims` is the number of dimensions. In this case, the shape is `{2, 2}`;

You should be aware that when you use the `[]` operator, the code does not immediately go and find the value. It creates a lightweight object that can be used to find a chunk of data, or for the last element in the sequence, the value itself. This has a some positives, but also one negative you need to be aware of.

Let's modify the code like this

  